/**
 * Auto-Generate Events from Naming Catalog
 *
 * This script reads EVENT_NAMING_CATALOG and creates/updates events in the database.
 * - Creates new events from catalog
 * - Updates existing auto-generated events
 * - Skips manually created events (autoGenerated: false)
 *
 * Run with: npx tsx --tsconfig tsconfig.json src/scripts/generate-events-from-naming.ts
 */

import "dotenv/config";
import { prisma } from "@/lib/db";
import { EVENT_NAMING_CATALOG } from "@/config/event-naming";

async function generateEventsFromNaming() {
  console.log(`üîÑ Auto-generating ${EVENT_NAMING_CATALOG.length} events from naming catalog...\n`);

  let created = 0;
  let updated = 0;
  let skipped = 0;

  for (const naming of EVENT_NAMING_CATALOG) {
    // Find category by name
    const category = await prisma.category.findUnique({
      where: { name: naming.category },
    });

    if (!category) {
      console.log(`‚ö†Ô∏è  Category "${naming.category}" not found for event "${naming.name}", skipping`);
      skipped++;
      continue;
    }

    // Determine recurrenceType based on ruleType
    let recurrenceType: 'YEARLY_LUNAR' | 'YEARLY_SOLAR' | 'NONE' = 'YEARLY_LUNAR';
    if (naming.ruleType === 'SOLAR') {
      recurrenceType = 'YEARLY_SOLAR';
    } else if (naming.ruleType === 'TITHI') {
      recurrenceType = 'YEARLY_LUNAR';
    }

    // Extract matching fields from ruleConfig
    const { tithi, maas, nakshatra, sankranti, isAdhikaOnly } = naming.ruleConfig;

    // Build event data
    const eventData = {
      name: naming.name,
      description: naming.description || null,
      eventType: naming.eventType,
      recurrenceType,
      importance: naming.importance,
      categoryId: category.id,

      // Matching criteria
      tithi: tithi || null,
      maas: maas || null,
      nakshatra: nakshatra || null,
      sankranti: sankranti || null,
      isAdhikaOnly: isAdhikaOnly || false,

      // Rule engine fields
      ruleType: naming.ruleType,
      ruleConfig: naming.ruleConfig,
      namingKey: naming.key,
      autoGenerated: true,

      tags: naming.tags || [],
    };

    // Check if event already exists
    const existing = await prisma.event.findUnique({
      where: { name: naming.name },
    });

    if (existing) {
      if (existing.autoGenerated) {
        // Update auto-generated event
        await prisma.event.update({
          where: { name: naming.name },
          data: eventData,
        });
        updated++;
        console.log(`‚úèÔ∏è  Updated: ${naming.name}`);
      } else {
        // Skip manually created event
        skipped++;
        console.log(`‚è≠Ô∏è  Skipped (manual): ${naming.name}`);
      }
    } else {
      // Create new event
      await prisma.event.create({
        data: eventData,
      });
      created++;
      console.log(`‚úÖ Created: ${naming.name}`);
    }
  }

  console.log(`\n${'='.repeat(70)}`);
  console.log(`üìä Summary:`);
  console.log(`  Created:  ${created}`);
  console.log(`  Updated:  ${updated}`);
  console.log(`  Skipped:  ${skipped}`);
  console.log(`  Total:    ${EVENT_NAMING_CATALOG.length}`);
  console.log(`${'='.repeat(70)}\n`);

  console.log(`‚úÖ Event auto-generation complete!`);
  console.log(`\n‚ö†Ô∏è  NEXT STEP: Regenerate occurrences via API`);
  console.log(`   POST http://localhost:3000/api/events/generate-occurrences`);
  console.log(`   Body: {"startDate":"2025-01-01", "endDate":"2027-12-31", "replace": true}\n`);
}

generateEventsFromNaming()
  .then(() => prisma.$disconnect())
  .catch((e) => {
    console.error('‚ùå Error:', e);
    prisma.$disconnect();
    process.exit(1);
  });
